import R from 'ramda';

/* Получение определенного массива по id */
const getArrayById = (state, id) => {
	return R.prop(id, state.arrays);
}

/* Получение всех массивов */
export const getArrays = state => {
	let arrays = [];
	for( var key in state.arrays ) {
		arrays[key] = state.arrays[key];
	}
	return arrays;
}

/* Получение концепций для вывода в фильтре */
export const getConceptInFilter = state => {
	let newValue = [];
	for(let key in state.concept) {
		let obj = {};
		obj.value = state.concept[key].id
		obj.label = state.concept[key].name;
		newValue[key] = obj;
	}
	return newValue;
}

/* Получение городов для вывода в фильтре */
export const getCityInFilter = state => {
	let newValue = [];
	for(let key in state.city) {
		let obj = {};
		obj.value = state.city[key].id
		obj.label = state.city[key].name;
		newValue[key] = obj;
	}
	return newValue;
}

/* Получение городов для вывода в меню */
export const getCityInMenu = state => {
	let newValue = [];
	for(let key in state.city) {
		newValue[key] = state.city[key];
	}
	return newValue.filter(el => {
    return el.menu === 1;
	});
}

/* Получение данных для страницы участков */
export const getPlots = state => {
	let plots = [];
	for( var key in state.plots ) {
		plots[key] = state.plots[key];
	}
	return plots;
}

/* Получение данных для страницы массива */
export const getArray = (state, ownProps) => {
	return getArrayById(state, ownProps.params.id);
}

/* Получение данных фильтра */
export const getFilterProps = state => {
	return state.filterProps;
}

/* Фильтрация массивов */
export const getFilteringArrays = state => {
	const {arrays, filterProps} = state;
	let newArrays = R.merge([], arrays);

	if(filterProps.price_min !== '') {
		const sort = el => +el.price_total >= +filterProps.price_min;
		newArrays = R.merge([], R.filter(sort, newArrays));
	}
	if(filterProps.price_max !== '') {
		const sort = el => +el.price_total <= +filterProps.price_max;
		newArrays = R.merge([], R.filter(sort, newArrays));
	}
	if(filterProps.area_min !== '') {
		const sort = el => +el.area >= +filterProps.area_min;
		newArrays = R.merge([], R.filter(sort, newArrays));
	}
	if(filterProps.area_max !== '') {
		const sort = el => +el.area <= +filterProps.area_max;
		newArrays = R.merge([], R.filter(sort, newArrays));
	}

	if(filterProps.city_id.length !== 0) {
		newArrays = R.merge([], R.filter(el => {
			let result = false;
			filterProps.city_id.forEach(n => {
				if(n == el.city_id) {
					result = true;
				}
			});
			return result;
		}, newArrays));
	}

	if(filterProps.concept_id.length !== 0) {
		newArrays = R.merge([], R.filter(el => {
			let result = false;
			filterProps.concept_id.forEach(n => {
				el.concept.forEach(c => {
					if(n == c.id) {
						result = true;
					}
				});
			});
			return result;
		}, newArrays));
	}

	let result = [];
	for( var key in newArrays ) {
		result[key] = newArrays[key];
	}

	return result;
}

export const getFilteringProps = state  => {
	return state.filterProps;
}

export const getCoords = coords => {
  return [+coords.split(',')[0], +coords.split(',')[1]];
}

export const getFilterMap = (el, filterProps) => {
	const array = el.properties._data;
	let result = true;

	if(result && filterProps.price_min !== '') {
		result = +array.price_total >= +filterProps.price_min;
	}
	if(result && filterProps.price_max !== '') {
		result = +array.price_total <= +filterProps.price_max;
	}
	if(result && filterProps.area_min !== '') {
		result = +array.area >= +filterProps.area_min;
	}
	if(result && filterProps.area_max !== '') {
		result = +array.area <= +filterProps.area_max;
	}
	if(result && filterProps.city_id.length !== 0) {
		let result2 = false;
		filterProps.city_id.forEach(n => {
			if(n == array.city_id) {
				result2 = true;
			}
		});
		result = result2;
	}
	if(result && filterProps.concept_id.length !== 0) {
		let result2 = false;
		filterProps.concept_id.forEach(n => {
			array.concept.forEach(c => {
				if(n == c.id) {
					result2 = true;
				}
			});
		});
		result = result2;
	}

	return result;
}