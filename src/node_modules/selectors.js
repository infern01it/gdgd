import R from 'ramda';

/* Получение определенного массива по id */
const getArrayById = (state, id) => {
	return R.prop(id, state.arrays);
}

/* Получение всех массивов */
export const getArrays = state => {
	let arrays = [];
	for( var key in state.arrays ) {
		arrays[key] = state.arrays[key];
	}
	return arrays;
}

/* Получение концепций для вывода в фильтре */
export const getConceptInFilter = state => {
	let concept = [];
	for( var key in state.concept ) {
		let obj = {};
		obj.value = state.concept[key].id;
		obj.label = state.concept[key].name;
		concept[key] = obj;
	}
	return concept;
}

/* Получение городов для вывода в фильтре */
export const getCityInFilter = state => {
	let city = [];
	for( var key in state.city ) {
		let obj = {};
		obj.value = state.city[key].id;
		obj.label = state.city[key].name;
		city[key] = obj;
	}
	return city;
}

/* Получение данных для страницы участков */
export const getPlots = state => {
	let plots = [];
	for( var key in state.plots ) {
		plots[key] = state.plots[key];
	}
	return plots;
}

/* Получение данных для страницы массива */
export const getArray = (state, ownProps) => {
	return getArrayById(state, ownProps.params.id);
}

/* Получение данных фильтра */
export const getFilterProps = state => {
	return state.filterProps;
}

/* Фильтрация массивов */
export const getFilteringArrays = state => {
	const {arrays, filterProps} = state;
	let newArrays = R.merge([], arrays);

	if(filterProps.price_min !== null) {
		const sort = el => +el.price_total >= +filterProps.price_min;
		newArrays = R.merge([], R.filter(sort, newArrays));
	}
	if(filterProps.price_max !== null) {
		const sort = el => +el.price_total <= +filterProps.price_max;
		newArrays = R.merge([], R.filter(sort, newArrays));
	}
	if(filterProps.area_min !== null) {
		const sort = el => +el.area >= +filterProps.area_min;
		newArrays = R.merge([], R.filter(sort, newArrays));
	}
	if(filterProps.area_max !== null) {
		const sort = el => +el.area <= +filterProps.area_max;
		newArrays = R.merge([], R.filter(sort, newArrays));
	}

	if(filterProps.city_id.length !== 0) {
		newArrays = R.merge([], R.filter(el => {
			let result = false;
			filterProps.city_id.map(n => {
				if(n == el.city_id) {
					result = true;
				}
			});
			return result;
		}, newArrays));
	}

	if(filterProps.concept_id.length !== 0) {
		newArrays = R.merge([], R.filter(el => {
			let result = false;
			filterProps.concept_id.map(n => {
				el.concept.map(c => {
					if(n == c.id) {
						result = true;
					}
				});
			});
			return result;
		}, newArrays));
	}

	let result = [];
	for( var key in newArrays ) {
		result[key] = newArrays[key];
	}

	return result;
}

export const getFilteringProps = state  => {
	return state.filterProps;
}