import R from 'ramda';

/* Преобразование объекта в массив */
export const toArr = obj => {
	let returnArrays = [];
	for( var key in obj ) {
		returnArrays.push(obj[key]);
	}
	return returnArrays;
}

/* Получение свойства состояния */
export const getPropState = (state, prop = null) => {
	if( prop === null ) {
		return state;
	} else {
		return state[prop];
	}
} 

/* Получение определенного массива по id */
const getArrayById = (state, id) => {
	return R.prop(id, state.arrays);
}

/* Получение всех массивов */
export const getArrays = (arrays) => {
	let returnArrays = [];
	for( var key in arrays ) {
		returnArrays[key] = arrays[key];
	}
	return returnArrays;
}

/* Получение концепций для вывода в фильтре */
export const getConceptInFilter = state => {
	let newValue = [];
	for(let key in state.concept) {
		let obj = {};
		obj.value = state.concept[key].id
		obj.label = state.concept[key].name;
		newValue[key] = obj;
	}
	return newValue;
}

/* Получение городов для вывода в фильтре */
export const getCityInFilter = state => {
	let newValue = [];
	for(let key in state.city) {
		let obj = {};
		obj.value = state.city[key].id
		obj.label = state.city[key].name;
		newValue[key] = obj;
	}
	return newValue;
}

/* Получение городов для вывода в меню */
export const getCityInMenu = state => {
	let newValue = [];
	for(let key in state.city) {
		newValue[key] = state.city[key];
	}
	return newValue.filter(el => {
    return el.menu === 1;
	});
}

/* Получение данных для страницы участков */
export const getPlots = arrays => {
	let plots = {};
	toArr(arrays).forEach(array => {
		array.land_plots.forEach(element => {
			element.array_id = array.id;
			element.array_name = array.name;
			plots[element.id] = element;
		});
	});
	return plots;
}

/* Получение данных для страницы участков с пагинацией */
export const getPlotsPage = (arrays, pageId) => {
	const perPage = 10;
	let plotsNew = [];
	let counter = 0;
	toArr(getPlots(arrays)).forEach(array => {
		if( counter >= perPage * (pageId - 1) && counter < perPage * pageId ) {
			plotsNew.push(array);
		}
		counter++;
	});
	return plotsNew;
}

/* Получение данных для страницы массива */
export const getArray = (state, ownProps) => {
	return getArrayById(state, ownProps.params.id);
}

/* Получение данных фильтра */
export const getFilterProps = state => {
	return state.filterProps;
}

/* Фильтрация массивов */
export const filteringArrays = (arrays, filterProps) => {
	let newArrays = R.merge([], arrays);

	if(filterProps.price_min !== '') {
		newArrays = R.merge([], R.filter(x => x.land_plots.length !== 0, R.map(el => {
			let returnArray = R.merge([], el);
			returnArray.land_plots = el.land_plots.filter(n => {
				return +n.price_total >= +filterProps.price_min * 1000000;
			});
			return returnArray;
		}, newArrays)));
	}
	if(filterProps.price_max !== '') {
		newArrays = R.merge([], R.filter(x => x.land_plots.length !== 0, R.map(el => {
			let returnArray = R.merge([], el);
			returnArray.land_plots = el.land_plots.filter(n => {
				return +n.price_total <= +filterProps.price_max * 1000000;
			});
			return returnArray;
		}, newArrays)));
	}
	if(filterProps.area_min !== '') {
		newArrays = R.merge([], R.filter(x => x.land_plots.length !== 0, R.map(el => {
			let returnArray = R.merge([], el);
			returnArray.land_plots = el.land_plots.filter(n => {
				return +n.area >= +filterProps.area_min;
			});
			return returnArray;
		}, newArrays)));
	}
	if(filterProps.area_max !== '') {
		newArrays = R.merge([], R.filter(x => x.land_plots.length !== 0, R.map(el => {
			let returnArray = R.merge([], el);
			returnArray.land_plots = el.land_plots.filter(n => {
				return +n.area <= +filterProps.area_max;
			});
			return returnArray;
		}, newArrays)));
	}
	if(filterProps.city_id.length !== 0) {
		newArrays = R.merge([], R.filter(el => {
			let result = false;
			filterProps.city_id.forEach(n => {
				if(n == el.city_id) {
					result = true;
				}
			});
			return result;
		}, newArrays));
	}
	if(filterProps.concept_id.length !== 0) {
		newArrays = R.merge([], R.filter(el => {
			let result = false;
			filterProps.concept_id.forEach(n => {
				el.concept.forEach(c => {
					if(n == c.id) {
						result = true;
					}
				});
			});
			return result;
		}, newArrays));
	}

	return newArrays;
}

/* Преобразование строковых координат в массив */
export const getCoords = coords => {
  return [+coords.split(',')[0], +coords.split(',')[1]];
}

/* Получение объекта массива по координатам */
export const getArrayFromCoords = (arrays, coords) => {
	return arrays.filter(el => {
		return +el.coords.split(',')[0] === coords[0] && +el.coords.split(',')[1] === coords[1];
	})[0];
}

/* Фильтрация массивов на карте */
export const filteringMap = (el, filterProps) => {
	const array = el.properties._data;
	let result = true;

	if(result && filterProps.price_min !== '') {
		const sort = el => el.land_plots.filter(n => {
			return +n.price_total >= +filterProps.price_min * 1000000;
		}).length !== 0;
		result = sort(array);
	}
	if(result && filterProps.price_max !== '') {
		const sort = el => el.land_plots.filter(n => {
			return +n.price_total <= +filterProps.price_max * 1000000;
		}).length !== 0;
		result = sort(array);
	}
	if(result && filterProps.area_min !== '') {
		const sort = el => el.land_plots.filter(n => {
			return +n.area >= +filterProps.area_min;
		}).length !== 0;
		result = sort(array);
	}
	if(result && filterProps.area_max !== '') {
		const sort = el => el.land_plots.filter(n => {
			return +n.area <= +filterProps.area_max;
		}).length !== 0;
		result = sort(array);
	}
	if(result && filterProps.city_id.length !== 0) {
		let result2 = false;
		filterProps.city_id.forEach(n => {
			if(n == array.city_id) {
				result2 = true;
			}
		});
		result = result2;
	}
	if(result && filterProps.concept_id.length !== 0) {
		let result2 = false;
		filterProps.concept_id.forEach(n => {
			array.concept.forEach(c => {
				if(n == c.id) {
					result2 = true;
				}
			});
		});
		result = result2;
	}

	return result;
}